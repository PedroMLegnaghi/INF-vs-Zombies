ESTRUTURACAO DAS PASTAS:
/INFVsZombies
│
├── root(raiz, nao é uma pasta) -> fica os arquivos ".c" 
├── include/        → Headers .h (separados)
├── resources/      → Imagens, áudios, fontes
├── output/         → game.exe e objetos .o
├── Makefile
└── .vscode/
==============================================================================
==============================================================================
//BASICO
TELA INICIAL:
****canto inferior esquerdo botão de exit
	*Imagem de fundo(videozinho que nem no PVSZ normal?)
	*Pede o nome e gênero (gênero e nome para depois usar tipo "bem vindo capitã(o) 				nome")
	*Dificuldade?(fácil, media e difícil?)

	*Escolha de deck de plantas?(lista de structs plantas disponíveis)
		@struct planta(nome, custo, desing(img),som?,cooldown)
		 	->& existe a planta empty de custo zero e imagem de grama, sem som e sem cooldown?
		
	*COMECAR

JOGO:
	*img do gramado, cada gramado é um lugar do array (que ocupa uma proporção) de  	plantas
		@definir proporção, os zombies andam 1 espaço de array
			, meu array tem 10000 espaços, a planta ocupa 50 espaços, com isso
			o zombie consegue andar passos menores, não vai chegar em um segundo
		@if array[i] ==0, então coloco a planta
	*quando zombie chega na posicao zero ("final") o jogo emite uma imagem
	de "voce perdeu" e acabou, volta para o menu de escolhar de planta
	*esc = menu?
		@sair?
		@mutar o som?
	*estrutura zombie, pode ter varios estilos escolhidos aleatoriamente
		@criar um array de estilos(png) e fazer um rand para escolher o 
		   estilo do zombie.
		@zombie: estilo(png?), vida, velocidade?(espacosdoarray/s(frame?), som?
	*quando ele chega na planta e comeca a atacar, determinar quanto dano por frame?)
	*pá para tirar as plantas?(atualiza array de plantas, colocando empty)

	Rectangle gramado[9*5]={0}
	posxInicial = (800-35*2(margin left-right))/9;
	posyInicial = 40+(450-(20+40)(margin left-right))/5;
	width = posxInicial;
	height = posyInicial;
	for(int...) { 
		gramado[i].x= posxInicial+posxInicial*i;
		gramado[i].y=...
		...
		...
	}
	for(int i)
	{
		//INTERCALAR CORES
		if(i&1){
		draw(gramado[i],LIGHTGREEN)
		}else{
			draw(gramado[i],DARKGREEN)
		}
		if(isHoveredBy){
		drawLine(gramadoi, BLACK)
		}

	}
	9colunas
	const int screenWidth = (800-35*2(margin left-right))/9;
	5linhas
    const int screenHeight = (450-20*2(margin left-right))/5;

=================TO BE DONE
3*definir tempo de spawn dos zombies e fazer seu spawn separado (ele esta tendo seu spawn junto com o spawn dos girassois, que usa sunGenerationTime)

4.1*Padronizar o tamanho das plantas e mudar tudo nas funcoes, para que todas fiquem genericas.
(possivelmente tenho que esperar até eu aprender as coisas de texturas)
4.2*arrumar desing jogo
4.3*fazer cenario jogo

5*otimizar as funcoes e os krlho, arrumar os comentarios, deixar o jogo redondinho

6*colocar som nos bglho

7*dividir em arquivos separados o jogo






























==============================================================================
==============================================================================
sol
const unsigned int tempoParaNascerNaturalmente = 10seg(em funcao dos frames=(framesPSeg*10/frameCount))
struct sol{
	Circle circle yellow
	png?
	sound?
	value = 50;
	
}
enum TypeOfPlants{
	sunflower,
	paenutThrower,
	saladThrower,
	...
}
enum CostOfPlants{
	//precicsa ser da mesma ordem do tipo da planta!

	sunflower = 50,
	peanutsThrower = 100,
}
planta
struct plant{
	Rectangle rectangle (que vai ser a planta)
	png?
	som?
	TypeOfPlants type
	int custo
}
ai eu vou ter as structs das plantas especificas
	struct sunflower{
		plant sunflower{
			Rectangle rectangle (que vai ser a planta)
			png?
			som?
			custo
		}
	}


*3	
Fazer a planta "peashooter"
	Nao precisa alterar nada, pois o que se refere ao tiro, 
	*3.1sera feito um array para armazenar os tiros dados(PeaShot)->Definir que, quando elemento for nulo, significa vazio
	*3.2 Fazer o struct peaShot ->int damage, Rectangle format, int img?, int sound?, int color, int velocity(pixels/frame),
								 int rowOfShot(used to optimize the verification of colision with zombies)
	*3.2.1 Fazer um define para cada tipo de peaShot, nesse caso, PeaShot NormalGreenPea
	*3.3 Fazer funcoes acerca da peashooter	
		*3.3.1->shootPea(Plant plantAryy[], peaShotsArr[])
			Dado um array de plantas e as peas shot
			-Se a planta for uma peashooter
				-(plant.existanceTime-plant.referenceTime) >= plant.actionTime
					->pea = (define normalGreenPea)
						->ATUALIZAR O ROWOFSHOT(PARA SER IGUAL ao row da planta(index i do for))
					//e entao, finalmente, adicionar no array
					->peaShotArr+=pea

		*3.3.2->DrawPeaShots(peaShotsArr[],int peaShotsArrTotalSize(o que foi atribuido em peaShotsArr[aqui]))
			-Desenhar todas as Peas até o tamanho do array
		*3.3.3->UpdatePeaShotsPosition(peaShotsArr[], int peaShotsArrTotalSize(o que foi atribuido em peaShotsArr[aqui]) )
			-Update todas as peas até o tamanho do array, adicionar pos x +=peaShot[i].velocity
		*3.3.6->RemovePeaFromArr(peaShotArr[], int indexDaPeaQueBateu)
			-Remove a pea do array(Utilizar em conjunto com "verifyPeaColision" para ver se ela bateu em algo(zombie))
		*3.3.7->UptadePeashotsGameplay(void)
			UpdatePeaShotsPosition()
			shootPea()
			DrawPeaShots()
			if(verifyPeaColision){
				RemovePeaFromArr
			}

	*1.2.1DrawZombie(zombie)->desenha o zombie
	*1.2.2DrawZombies(zombiesArr)->for each zombie, draw zombie
	*1.2.3Zombie CreateZombie(void)->
		Escolhe uma linha e uma coluna de lawn aleatoriamente, pega as coord
		(x,y) delas e centraliza o zombie e adiciona o zombie no array
1*ZOMBIES
ZombiesArr[número alto]
*1.1 definir a estrutura zombie
Struct Zombies{
Png?
Sound?
Color color
Int Velocity
Rectange format
Int health
Int RowOfZombie
}
	*1.2.4Void updateZombiePosition(Zombie zombieArr)->adiciona zombie.velocity à coord X do zombie
*1.2 funcoes
	*1.2.6RemoveZombie(usar com if healthZombie==0)(Zombie zombieArr[], int indexASerRemovido)->
ZombieArr[indexASerRemovido]={0}
*3.3.5->Int verifyPeaColision(peaShotsArr[],int peaShotsArrTotalSize(o que foi atribuido em peaShotsArr[aqui]), Rectangle zombies[zombie])
*3.3.4->Int verifyIfZombieSameRowPeashot(zombie, peaShot)
	*1.2.5Void updateZombieHealth(zombie *zombie, int peaShotDamage)->
If check colision peaShot e Zombie, fazer Zombie.health-=peaShotDamage

	**void updatePeas(){
		shootPea
		//updatePositionShotsPosition
		UpdatePeaShotsGameplay
		if(verifyColisionPeaShotZombie>=0){
			RemovePeaFromArr[indexOfPeaToBeRemoved]
		}

	}
	*1.2.5 void updateZombies(){
		//if zombie isnt attackign, update its position
		 if(zombieArr[i].isAttacking!=1)    {
    UpdateZombiePosition(&zombieArr[i]);
    }
		if(verifyColision){
		updateZombieHealth()
		}
		if(zombie[i].health<=0){
			RemoveZombie(i)
		}
	}
	*1.2.7 ZombieAttackPlant
		->if check colision zombie.format&&plant.format, plant.health-=zombie.damag
		->Fazer a planta piscar (sofreu hit) (tocar barulho de comer do zombie)



	

