ESTRUTURACAO DAS PASTAS:
/INFVsZombies
│
├── root(raiz, nao é uma pasta) -> fica os arquivos ".c" 
├── include/        → Headers .h (separados)
├── resources/      → Imagens, áudios, fontes
├── output/         → game.exe e objetos .o
├── Makefile
└── .vscode/
==============================================================================
==============================================================================
//BASICO
TELA INICIAL:
****canto inferior esquerdo botão de exit
	*Imagem de fundo(videozinho que nem no PVSZ normal?)
	*Pede o nome e gênero (gênero e nome para depois usar tipo "bem vindo capitã(o) 				nome")
	*Dificuldade?(fácil, media e difícil?)

	*Escolha de deck de plantas?(lista de structs plantas disponíveis)
		@struct planta(nome, custo, desing(img),som?,cooldown)
		 	->& existe a planta empty de custo zero e imagem de grama, sem som e sem cooldown?
		
	*COMECAR

JOGO:
	*img do gramado, cada gramado é um lugar do array (que ocupa uma proporção) de  	plantas
		@definir proporção, os zombies andam 1 espaço de array
			, meu array tem 10000 espaços, a planta ocupa 50 espaços, com isso
			o zombie consegue andar passos menores, não vai chegar em um segundo
		@if array[i] ==0, então coloco a planta
	*quando zombie chega na posicao zero ("final") o jogo emite uma imagem
	de "voce perdeu" e acabou, volta para o menu de escolhar de planta
	*esc = menu?
		@sair?
		@mutar o som?
	*estrutura zombie, pode ter varios estilos escolhidos aleatoriamente
		@criar um array de estilos(png) e fazer um rand para escolher o 
		   estilo do zombie.
		@zombie: estilo(png?), vida, velocidade?(espacosdoarray/s(frame?), som?
	*quando ele chega na planta e comeca a atacar, determinar quanto dano por frame?)
	*pá para tirar as plantas?(atualiza array de plantas, colocando empty)

	Rectangle gramado[9*5]={0}
	posxInicial = (800-35*2(margin left-right))/9;
	posyInicial = 40+(450-(20+40)(margin left-right))/5;
	width = posxInicial;
	height = posyInicial;
	for(int...) { 
		gramado[i].x= posxInicial+posxInicial*i;
		gramado[i].y=...
		...
		...
	}
	for(int i)
	{
		//INTERCALAR CORES
		if(i&1){
		draw(gramado[i],LIGHTGREEN)
		}else{
			draw(gramado[i],DARKGREEN)
		}
		if(isHoveredBy){
		drawLine(gramadoi, BLACK)
		}

	}
	9colunas
	const int screenWidth = (800-35*2(margin left-right))/9;
	5linhas
    const int screenHeight = (450-20*2(margin left-right))/5;

==============================================================================
==============================================================================
sol
const unsigned int tempoParaNascerNaturalmente = 10seg(em funcao dos frames=(framesPSeg*10/frameCount))
struct sol{
	Circle circle yellow
	png?
	sound?
	value = 50;
	
}
enum TypeOfPlants{
	sunflower,
	paenutThrower,
	saladThrower,
	...
}
enum CostOfPlants{
	//precicsa ser da mesma ordem do tipo da planta!

	sunflower = 50,
	peanutsThrower = 100,
}
planta
struct plant{
	Rectangle rectangle (que vai ser a planta)
	png?
	som?
	TypeOfPlants type
	int custo
}
ai eu vou ter as structs das plantas especificas
	struct sunflower{
		plant sunflower{
			Rectangle rectangle (que vai ser a planta)
			png?
			som?
			custo
		}
	}



=================TO BE DONE



*3	
Fazer a planta "peashooter"
	Nao precisa alterar nada, pois o que se refere ao tiro, 
	*3.1sera feito um array para armazenar os tiros dados(PeaShot)->Definir que, quando elemento for nulo, significa vazio
	*3.2 Fazer o struct peaShot ->int damage, Rectangle format, int img?, int sound?, int color, int velocity, int timeOfCreation,
								 int rowOfShot(used to optimize the verification of colision with zombies)
	*3.2.1 Fazer um define para cada tipo de peaShot, nesse caso, PeaShot NormalGreenPea
	*3.3 Fazer funcoes acerca da peashooter	
		*3.3.1->shootPea(Plant plantAryy[], peaShotsArr[])
			Dado um array de plantas e as peas shot
			-Se a planta for uma peashooter
				-Se seu tempo >= timeOfCreation de peaShot
					->peaShotArr+=NormalGreenPea(=um define, como feito em *3.2.1) 

		*3.3.2->DrawPeaShots(peaShotsArr[],int peaShotsArrTotalSize(o que foi atribuido em peaShotsArr[aqui]))
			-Desenhar todas as Peas até o tamanho do array
		*3.3.3->UpdatePeaShotsPosition(peaShotsArr[], int peaShotsArrTotalSize(o que foi atribuido em peaShotsArr[aqui]) )
			-Update todas as peas até o tamanho do array
		*3.3.4->Int verifyIfZombieSameRowPeashot(zombie, peaShot)
			-se (a coordenada) nao for maior que (o numero de linhas de grama -1) (mas pode ser igual)
			-se a coordenada y do zombie estiver entre (a coordenada y da grama no index [peaShot.rowOfShot]) e (a coordenada y da grama no index[peaShot.rowOfShot+1])
			-return 1(true)
			-else return 0(false)
			-OBS:eu posso fazer isso pois meu plantsArr coincide com o LawnArray no quesito de locais, entao quando inicializo o peaShot, consigo
				 track from which row it was shot
		*3.3.5->Int verifyPeaColision(peaShotsArr[],int peaShotsArrTotalSize(o que foi atribuido em peaShotsArr[aqui]), Rectangle zombies[zombie])
 			-Verifica se houve colisao, retorna 1(true) ou 0(false)
			-Em um for de 0 ate o totalSize do arrPeaShots, 
				em um for de 0 ate totalSize do arrZombies
				-Se estiverem peaShot e zombie na mesma row de lawn (verifyIfZombieSameRowPeashot(zombies[j],peaShotsArr[i]))
					->return(checkColision com o PeaShotsArr[i].format e o zombie.fomart)
		*3.3.6->RemovePeaFromArr(peaShotArr[], int indexDaPeaQueBateu)
			-Remove a pea do array(Utilizar em conjunto com "verifyPeaColision" para ver se ela bateu em algo(zombie))
		*3.3.7->UptadePeashotsGameplay(void)
			UpdatePeaShotsPosition()
			shootPea()
			DrawPeaShots()
			if(verifyPeaColision){
				RemovePeaFromArr
			}

4*Padronizar o tamanho das plantas e mudar tudo nas funcoes, para que todas fiquem genericas.
(possivelmente tenho que esperar até eu aprender as coisas de texturas)




